(()=>{var V=Object.create;var K=Object.defineProperty;var U=Object.getOwnPropertyDescriptor;var G=Object.getOwnPropertyNames;var q=Object.getPrototypeOf,J=Object.prototype.hasOwnProperty;var Q=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var X=(n,t,h,b)=>{if(t&&typeof t=="object"||typeof t=="function")for(let y of G(t))!J.call(n,y)&&y!==h&&K(n,y,{get:()=>t[y],enumerable:!(b=U(t,y))||b.enumerable});return n};var Y=(n,t,h)=>(h=n!=null?V(q(n)):{},X(t||!n||!n.__esModule?K(h,"default",{value:n,enumerable:!0}):h,n));var F=Q(S=>{var re=function(){"use strict";let n="1.1.0";function t(e){alert(`Mod ERROR:
`+e);let i=new Error(e);throw console.error(i),i}let h=new TextEncoder;function b(e){return!!e&&typeof e=="object"&&!Array.isArray(e)}function y(e){let i=new Set;return e.filter(r=>!i.has(r)&&i.add(r))}let M=new Map,A=new Set;function j(e){A.has(e)||(A.add(e),console.warn(e))}function P(e){let i=[],r=new Map,s=new Set;for(let l of k.values()){let f=l.patching.get(e.name);if(f){i.push(...f.hooks);for(let[c,o]of f.patches.entries())r.has(c)&&r.get(c)!==o&&j(`ModSDK: Mod '${l.name}' is patching function ${e.name} with same pattern that is already applied by different mod, but with different pattern:
Pattern:
${c}
Patch1:
${r.get(c)||""}
Patch2:
${o}`),r.set(c,o),s.add(l.name)}}i.sort((l,f)=>f.priority-l.priority);let u=function(l,f){if(f.size===0)return l;let c=l.toString().replaceAll(`\r
`,`
`);for(let[o,d]of f.entries())c.includes(o)||j(`ModSDK: Patching ${l.name}: Patch ${o} not applied`),c=c.replaceAll(o,d);return(0,eval)(`(${c})`)}(e.original,r),g=function(l){var f,c;let o=(c=(f=E.errorReporterHooks).hookChainExit)===null||c===void 0?void 0:c.call(f,e.name,s),d=u.apply(this,l);return o?.(),d};for(let l=i.length-1;l>=0;l--){let f=i[l],c=g;g=function(o){var d,p;let m=(p=(d=E.errorReporterHooks).hookEnter)===null||p===void 0?void 0:p.call(d,e.name,f.mod),v=f.hook.apply(this,[o,w=>{if(arguments.length!==1||!Array.isArray(o))throw new Error(`Mod ${f.mod} failed to call next hook: Expected args to be array, got ${typeof w}`);return c.call(this,w)}]);return m?.(),v}}return{hooks:i,patches:r,patchesSources:s,enter:g,final:u}}function R(e,i=!1){let r=M.get(e);if(r)i&&(r.precomputed=P(r));else{let s=window,u=e.split(".");for(let c=0;c<u.length-1;c++)if(s=s[u[c]],!b(s))throw new Error(`ModSDK: Function ${e} to be patched not found; ${u.slice(0,c+1).join(".")} is not object`);let g=s[u[u.length-1]];if(typeof g!="function")throw new Error(`ModSDK: Function ${e} to be patched not found`);let l=function(c){let o=-1;for(let d of h.encode(c)){let p=255&(o^d);for(let m=0;m<8;m++)p=1&p?-306674912^p>>>1:p>>>1;o=o>>>8^p}return((-1^o)>>>0).toString(16).padStart(8,"0").toUpperCase()}(g.toString().replaceAll(`\r
`,`
`)),f={name:e,original:g,originalHash:l};r=Object.assign(Object.assign({},f),{precomputed:P(f),router:()=>{},context:s,contextProperty:u[u.length-1]}),r.router=function(c){return function(...o){return c.precomputed.enter.apply(this,[o])}}(r),M.set(e,r),s[r.contextProperty]=r.router}return r}function $(){let e=new Set;for(let i of k.values())for(let r of i.patching.keys())e.add(r);for(let i of M.keys())e.add(i);for(let i of e)R(i,!0)}function W(){let e=new Map;for(let[i,r]of M)e.set(i,{name:i,original:r.original,originalHash:r.originalHash,sdkEntrypoint:r.router,currentEntrypoint:r.context[r.contextProperty],hookedByMods:y(r.precomputed.hooks.map(s=>s.mod)),patchedByMods:Array.from(r.precomputed.patchesSources)});return e}let k=new Map;function D(e){k.get(e.name)!==e&&t(`Failed to unload mod '${e.name}': Not registered`),k.delete(e.name),e.loaded=!1,$()}function _(e,i,r){typeof e=="string"&&typeof i=="string"&&(alert(`Mod SDK warning: Mod '${e}' is registering in a deprecated way.
It will work for now, but please inform author to update.`),e={name:e,fullName:e,version:i},i={allowReplace:r===!0}),e&&typeof e=="object"||t("Failed to register mod: Expected info object, got "+typeof e),typeof e.name=="string"&&e.name||t("Failed to register mod: Expected name to be non-empty string, got "+typeof e.name);let s=`'${e.name}'`;typeof e.fullName=="string"&&e.fullName||t(`Failed to register mod ${s}: Expected fullName to be non-empty string, got ${typeof e.fullName}`),s=`'${e.fullName} (${e.name})'`,typeof e.version!="string"&&t(`Failed to register mod ${s}: Expected version to be string, got ${typeof e.version}`),e.repository||(e.repository=void 0),e.repository!==void 0&&typeof e.repository!="string"&&t(`Failed to register mod ${s}: Expected repository to be undefined or string, got ${typeof e.version}`),i==null&&(i={}),i&&typeof i=="object"||t(`Failed to register mod ${s}: Expected options to be undefined or object, got ${typeof i}`);let u=i.allowReplace===!0,g=k.get(e.name);g&&(g.allowReplace&&u||t(`Refusing to load mod ${s}: it is already loaded and doesn't allow being replaced.
Was the mod loaded multiple times?`),D(g));let l=o=>{typeof o=="string"&&o||t(`Mod ${s} failed to patch a function: Expected function name string, got ${typeof o}`);let d=c.patching.get(o);return d||(d={hooks:[],patches:new Map},c.patching.set(o,d)),d},f={unload:()=>D(c),hookFunction:(o,d,p)=>{c.loaded||t(`Mod ${s} attempted to call SDK function after being unloaded`);let m=l(o);typeof d!="number"&&t(`Mod ${s} failed to hook function '${o}': Expected priority number, got ${typeof d}`),typeof p!="function"&&t(`Mod ${s} failed to hook function '${o}': Expected hook function, got ${typeof p}`);let v={mod:c.name,priority:d,hook:p};return m.hooks.push(v),$(),()=>{let w=m.hooks.indexOf(v);w>=0&&(m.hooks.splice(w,1),$())}},patchFunction:(o,d)=>{c.loaded||t(`Mod ${s} attempted to call SDK function after being unloaded`);let p=l(o);b(d)||t(`Mod ${s} failed to patch function '${o}': Expected patches object, got ${typeof d}`);for(let[m,v]of Object.entries(d))typeof v=="string"?p.patches.set(m,v):v===null?p.patches.delete(m):t(`Mod ${s} failed to patch function '${o}': Invalid format of patch '${m}'`);$()},removePatches:o=>{c.loaded||t(`Mod ${s} attempted to call SDK function after being unloaded`),l(o).patches.clear(),$()},callOriginal:(o,d,p)=>(c.loaded||t(`Mod ${s} attempted to call SDK function after being unloaded`),typeof o=="string"&&o||t(`Mod ${s} failed to call a function: Expected function name string, got ${typeof o}`),Array.isArray(d)||t(`Mod ${s} failed to call a function: Expected args array, got ${typeof d}`),function(m,v,w=window){return R(m).original.apply(w,v)}(o,d,p)),getOriginalHash:o=>(typeof o=="string"&&o||t(`Mod ${s} failed to get hash: Expected function name string, got ${typeof o}`),R(o).originalHash)},c={name:e.name,fullName:e.fullName,version:e.version,repository:e.repository,allowReplace:u,api:f,loaded:!0,patching:new Map};return k.set(e.name,c),Object.freeze(f)}function T(){let e=[];for(let i of k.values())e.push({name:i.name,fullName:i.fullName,version:i.version,repository:i.repository});return e}let E,O=function(){if(window.bcModSdk===void 0)return window.bcModSdk=function(){let e={version:n,apiVersion:1,registerMod:_,getModsInfo:T,getPatchingInfo:W,errorReporterHooks:Object.seal({hookEnter:null,hookChainExit:null})};return E=e,Object.freeze(e)}();if(b(window.bcModSdk)||t("Failed to init Mod SDK: Name already in use"),window.bcModSdk.apiVersion!==1&&t(`Failed to init Mod SDK: Different version already loaded ('1.1.0' vs '${window.bcModSdk.version}')`),window.bcModSdk.version!==n&&(alert(`Mod SDK warning: Loading different but compatible versions ('1.1.0' vs '${window.bcModSdk.version}')
One of mods you are using is using an old version of SDK. It will work for now but please inform author to update`),window.bcModSdk.version.startsWith("1.0.")&&window.bcModSdk._shim10register===void 0)){let e=window.bcModSdk,i=Object.freeze(Object.assign(Object.assign({},e),{registerMod:(r,s,u)=>r&&typeof r=="object"&&typeof r.name=="string"&&typeof r.version=="string"?e.registerMod(r.name,r.version,typeof s=="object"&&!!s&&s.allowReplace===!0):e.registerMod(r,s,u),_shim10register:!0}));window.bcModSdk=i}return window.bcModSdk}();return typeof S<"u"&&(Object.defineProperty(S,"__esModule",{value:!0}),S.default=O),O}()});var z=Y(F());function H(n,t=3e3){ServerBeep={Timer:CommonTime()+t,Message:n}}function x(n,t,h,b,y,M=!1){InventoryGet(n,h)==null&&InventoryWear(Player,t,h,b,y,!1)}function N(n){switch(getRandomInt(20)){case 0:InventoryRemove(n,"Cloth");break;case 1:InventoryRemove(n,"ClothAccessory");break;case 2:InventoryRemove(n,"Suit");break;case 3:InventoryRemove(n,"ClothLower");break;case 4:InventoryRemove(n,"SuitLower");break;case 5:InventoryRemove(n,"Bra");break;case 6:InventoryRemove(n,"Corset");break;case 7:InventoryRemove(n,"Panties");break;case 8:InventoryRemove(n,"SocksLeft");break;case 9:InventoryRemove(n,"SocksRight");break;case 10:InventoryRemove(n,"Socks");break;case 11:InventoryRemove(n,"Garters");break;case 12:InventoryRemove(n,"Shoes");break;case 13:InventoryRemove(n,"Hat");break;case 14:InventoryRemove(n,"Gloves");break;case 15:InventoryRemove(n,"LeftHand");break;case 16:InventoryRemove(n,"RightHand");break;case 17:InventoryRemove(n,"Bracelet");break;case 18:InventoryRemove(n,"Mask");break;default:break}}var C,I=0,B="#56AB56";function L(){C=setInterval(function(){ee()},5*1e3)}function Z(){clearInterval(C)}function ee(){let n=getRandomInt(51),t=getRandomInt(101);n>t&&(oe(),I++)}a;function oe(){switch(I){case 0:break;case 1:x(Player,"HempRope","ItemLegs",B,1);break;case 2:x(Player,"HempRope","ItemArms",B,1);break;case 3:break;default:break}I>10&&N(player),I>100&&Z()}var pe=z.default.registerMod({name:"AES",fullName:"Ainaras Event Mod",version:"0.01",repository:"https://github.com/Ainaradev7/AES"});function te(){console.log("AES: Initiated"),H("AES: Initiated"),L()}te();})();
